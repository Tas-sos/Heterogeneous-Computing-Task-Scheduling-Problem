/*
 * Problem.h
 *
 *  Created on: G-lts Team Lab
 *      Author: Tas-sos
 */

#include <utility> // Για τα pairs.

using namespace std;


#ifndef PROBLEM_H_
#define PROBLEM_H_


class Problem {

private :


	int processors_number; // Θα κρατάει τον αριθμό των επεξεργαστών.
	int tasks_number; // Θα κρατάει τον αριθμό των εργασιών.

	double min_value; // Θα κρατάει την ελάχιστη τιμή.

	int min_posTASK; // Θα κρατάει τον αριθμό της εργασία που έχει την μικρότερη τιμή.
	int min_posCPU; // Θα κρατάει τον αριθμό του επεξεργαστή που έχει την εργασία με την μικρότερη τιμή.

	int posa_tasks_eminan; // Τεφτέρι για τις διεργασίες που απομένουν.

	double ** Tasks_and_processors; /* Δυναμικός 2D πίνακας, όπου θα έχει "tasks_number" γραμμές και "processors_number" στήλες.
	Στον πίνακα αυτό θα αποθηκεύονται οι τιμές των *αδρομολόγιτων* διεργασιών σε κάθε επεξεργαστεί. Κατ επέκταση αρχικά ο πίνακας
	αυτός θα γεμίσει κάθως θα διαβαστουν τα δεδομένα από το αρχείο του προβλήματος.
	Έπειτα καθώς δρομολογούνται οι διεργασίες σε κάθε δρομολόγηση διεργασίας, θα σημαδεύονται με -1 όλες οι
	τιμές της συγκεκριμένης δρομολογημένης πλέον διεργασίες σε κάθε επεξεργαστή.  */

	double * Total_processors_Time; /* Δυναμικός πίνακας, όπου θα έχει μέγεθος-θέσεις "processors_number" και θα κρατάει
	τον συνολικό χρόνο του κάθε επεξεργαστή. Ο χρόνος όλων των επεξεργαστών ξεκινάει με 0. Έπειτα όμως θα αλλάζει ο χρόνος κάθε
	επεξεργαστεί με τις τυχών διεργασίες που θα δρομολογούνται σε αυτόν. */

	pair<double, int> * texon_minmum_xroni_apo_ta_MI_dromologoumena_Task;

	/* ==================================== Ιδιωτικοί μέθοδοι. ==================================== */

	void Euresi_elaxiston_timon_apo_ta_mi_dromologoumena_tasks();
		/* Μέθοδος η οποία :
		 * 		- Βρίσκει για κάθε *ΔΙΕΡΓΑΣΊΑ* σε ποια CPU έχει τον ελάχιστο χρόνο.
		 * 	ΠΡΟΣΟΧΉ : Ο υπολογισμούς του ελάχιστου χρόνου μια διεργασίας σε κάποια cpu *ΣΥΝΥΠΟΛΟΓΊΖΕΤΑΙ* από :
		 *
		 * 				- Τον χρόνο της διεργασίας.
		 * 											+
		 *	- Τον χρόνο που χρειάζεται η εκάστοτε cpu που δοκιμάζουμε μέχρι να εκτελέσει, τις *ΠΡΟΗΓΟΎΜΕΝΕΣ* τυχόν δρομολογημένες σε αυτή διεργασίες.
		 */



		void Find_min_by_min();
		/* Μέθοδος η οποία :
		 *		Από τον πίνακα ( "texon_minmum_xroni_apo_ta_MI_dromologoumena_Task" ) που κρατάει τους ελάχιστους χρόνους που βρήκε
		 *		για τις *εναπομείναντες* μη δρομολογούμενες διεργασίες.
		 *			- Βρίσκει την ελάχιστη διεργασία από αυτές.
		 *
		 *		- Αναλυτικότερα :
		 *			Αναζητάει στον πίνακα αυτόν την μικρότερη - ελάχιστη σε χρόνο διεργασία και συγκεκριμένα για αυτή κρατάει :
		 *				- ποια διεργασία είναι,
		 *				- σε ποιον επεξεργαστή είναι,
		 *				- & τον χρόνο της.
		 *
		 *		- Τέλος "καθαρίζει" ( σημαδεύει με -1 ) όλο τον πίνακα "texon_minmum_xroni_apo_ta_MI_dromologoumena_Task".
		 *			> Αυτό το κάνει διότι, όπως αναφέρετε παραπάνω αυτός ο πίνακας *κρατάει τις ελάχιστες τιμές που βρίσκονται για τις
		 *			ΜΗ δρομολογούμενες διεργασίες*. Οπότε όταν μια διεργασία δρομολογείτε πλέον δε θα πρέπει να κρατιέτε και η ξεχασμένη
		 *			ελάχιστη τιμή της σε αυτό τον πίνακα.
		 *			Αν δεν τον "καθάριζα" στην θέση/διεργασία που δρομολόγησα τις επόμενες φορές δεν θα άλλαζε η τιμή ( διότι από τον
		 *			πίνακα που βρίσκω τις ελάχιστες τιμές για της μη δρομολογούμενες διεργασίες εφόσον κάποια διεργασία έχει δρομολογηθεί
		 *			παραλείπετε ) , οπότε καινούρια ελάχιστη τιμή στην αντίστοιχη θέση/διεργασία του πίνακα αυτού *δεν* θα υπήρχε,
		 *			αλλά θα υπήρχε η παλιά τιμή και ίσος αυτό δημιουργούσε προβλήματα.
		 *
		 *			Ίσος σε αυτόν τον πίνακα κάποια στιγμή πρέπει να σκεφτώ κάτι καλύτερο από το να τον σκανάρω απλώς από την αρχή μέχρι
		 *			το τέλος και να παραλείπω τις θέσεις που έχουν σημαδευτεί με -1. Ίσος μπορέσω να κάνω κάτι καλύτερο.
		 * */



		void removing_the_current_minimum_task_by_all_processors();
		/* Μέθοδος η οποία :
		 * 		- Αφαιρεί την τρέχουσα ελάχιστη σε χρόνο διεργασία που δρομολογήθηκε.
		 *
		 * 	- Αναλυτικότερα :
		 * 		Αφαιρεί ( σημαδεύει με -1) σε *ΌΛΟΥΣ* τους επεξεργαστές του πίνακα "Tasks_and_processors"
		 * 		την δρομολογημένη διεργασία.
		 */



		bool Number_of_Tasks();
		/* Μέθοδος η οποία :
		 * 		- Επιστρέφει :
		 * 						- Αληθής : Αν υπάρχουν αδρομολόγητες διεργασίες ( posa_tasks_eminan > 0 ).
		 * 						- Ψευδής : Αν έχουν δρομολογηθεί όλες η διεργασίες ( posa_tasks_eminan == 0 ).
		 */



		void Final_Min_Min_Time();
		/* Μέθοδος η οποία :
		 * 		- Θα καλείτε κατά κύριο λόγο στο τέλος, έπειτα από κλήση της μεθόδου Min-Min.
		 * 		- Εμφανίζει σε ποιον επεξεργαστή έχουμε τον *μικρότερο* χρόνο
		 * 		( σε σύγκριση με όλους του επεξεργαστές του πίνακα "Total_processors_Time"  ).
		 */



		void Find_max_by_min();
		/* Μέθοδος η οποία γενικά είναι ολόιδια με την "Find_min_by_min()" με την διαφορά πως :
		 *		Από τον πίνακα ( "texon_minmum_xroni_apo_ta_MI_dromologoumena_Task" ) που κρατάει τους ελάχιστους χρόνους που βρήκε
		 *		για τις *αναπομήναντες* μη δρομολογούμενες διεργασίες.
		 *			- Βρήσκει την *ΜΈΓΙΣΤΗ* διεργασία από αυτές.
		 *
		 *		- Αναλυτικότερα :
		 *			Αναζητάει στον πίνακα αυτόν την *μεγαλύτερη - μέγιστη* σε χρόνο διεργασία και συγκεκριμένα για αυτή κρατάει :
		 *				- ποια διεργασία είναι,
		 *				- σε ποιον επεξεργαστή είναι,
		 *				- & τον χρόνο της.
		 *
		 *		...............................................................................................................
		 *
		 *		( Κατά τα άλλα επειδή είναι ακριβώς ίδια με την "Find_min_by_min()" και οπότε για να μην γράφουμε τα ίδια, διαβάστε
		 *		παραπάνω τι άλλο κάνει. )
		 *
		 */



		void Final_Max_Min_Time();
		/* Μέθοδος η οποία είναι παρόμοια με την μέθοδο "Final_Min_Min_Time" :
		 * 		- Θα καλείτε κατά κύριο λόγο στο τέλος, έπειτα από κλήση της μεθόδου Max-Min.
		 *
		 *	> Σκανάρει τον πίνακα "Total_processors_Time", που κρατούνται οι χρόνοι των επεξεργαστών
		 *	 ύστερα από την δρομολόγηση σε αυτούς διεργασιών & βρίσκει τον επεξεργαστή με τον *ΜΕΓΑΛΎΤΕΡΟ* χρόνο.
		 *
		 * 		- Εμφανίζει λοιπόν σε ποιον επεξεργαστή έχουμε τον *μεγαλύτερο* χρόνο.
		 */





public:

	Problem();
	/* Μέθοδος η οποία :
	 * 			- Ζητάει από τον χρήστη τον αριθμό των διεργασιών & των επεξεργαστών.
	 * 			- Ορίζονται οι θέσεις των δυναμικών πινάκων.
	 */



	void getDataFromFile();
	/* Μέθοδος η οποία :
	 * 		- Ανοίγει το αρχείο με τα δεδομένα του προβλήματος ( τους χρόνους των εργασιών σε κάθε επεξεργαστή)
	 * 		  & τα φορτώνει στις κατάλληλες δομές.
	 *
	 * 	Αναλυτικότερα : Στον πίνακα "Tasks_and_processors" που έχει θέσεις (εργασίες x επεξεργαστές). Οπότε
	 * 	Γραμμή/ες = διεργασία.
	 * 	Στήλη/ες = επεξεργαστής.
	 *
	 * 	Όπως διαβάζει τους χρόνους από το αρχείο, τους βάζει τον έναν μετά τον άλλο στους κατάλληλους επεξεργαστές.
	 * 	Αυτό η επανάληψη γίνεται κάθε φορά επί όσοι είναι οι επεξεργαστές.
	 * 	Και η παραπάνω επανάληψη επίσης επαναλαμβάνεται μέχρι να τελειώσουν οι διεργασίες - το αρχείο.
	 */



	void PrintDatabyProcessors();
	/* Μέθοδος η οποία :
	 * 		- Εμφανίζει τα στοιχεία του πίνακα "Tasks_and_processors".
	 * 			Δηλαδή για κάθε *αδρομολόγητη" διεργασία τις τιμές της σε κάθε επεξεργαστή.
	 */



	void MinMin();
	/* Μέθοδος η οποία :
	 * 		- Επιλύει το πρόβλημα χρονοπογραμματισμού διεργασιών με τον αλγόριθμο Min-Min χρησιμοποιώντας τις κατάλληλες μεθόδους
	 * 		που έχουν κατασκευαστή.
	 */



	void MaxMin();
	/* Μέθοδος η οποία :
	 * 		- Επιλύει το πρόβλημα χρονοπογραμματισμού διεργασιών με τον αλγόριθμο Max-Min χρησιμοποιώντας τις κατάλληλες μεθόδους.
	 * 		που έχουν κατασκευαστή.
	 */













	virtual ~Problem();
};

#endif /* PROBLEM_H_ */
